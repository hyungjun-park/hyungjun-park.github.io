---
layout: post
title:  "[도서] Good Code, Bad Code - 2. 추상화 계층"
date:   2023-07-05 22:00:25 +0900
categories: book
---

# 2. 추상화 계층
**주요 내용**
- 깔끔한 추상화 계층을 통해 문제를 하위 문제로 세분화하는 방법
- 추상화 계층이 코드 품질의 요소를 달성하는 데 어떻게 도움이 되는지
- API 및 구현 세부 사항
- 함수, 클래스 및 인터페이스를 사용해 코드를 추상화 계층으로 나누는 방법

코드를 구성하는 방법은 코드 품질의 기본적인 측면 중 하나이며, 코드를 잘 구성한다는 것은 간결한 추상화 계층을 만드는 것으로 귀결될 때가 많다.
잘 추상화된 코드는 가독성, 모듈성, 재사용성, 일반화성 및 테스트 용이성이 크게 개선된다.

## 2.1 널값 및 의사코드 규약
> 해당 장의 예제 코드에서 어떻게 널값을 다루는지 설명하는 내용이다.

프로그래밍 언어에는 값이 없다는 개념을 표현하기 위해 널값을 사용한다. 이 널값은 유용하면서도 문제가 많다.
- 값이 제공되지 않거나 함수가 원하는 결과를 반환할 수 없는 경우가 자주 발생하기 때문에 '값이 없다' 또는 '부재한다'는 재념은 유용하다.
- 값이 널일 수 있거나 혹은 널이면 안 되는 경우가 항상 명백한 것은 아니라서 문제가 발생한다. 개발자들은 변수에 액세스하기 전에 널값인지 확인하는 것을 자주 잊어버린다. (NullPointException)

널 안전성(null safety) 혹은 보이드 안전성(void safety)에 대한 생각이 점점 더 많은 추진력을 얻고 있다. 이렇게 하면 널값이 가능할 경우 그에 맞게 표시해야 하고 컴파일러는 반드시 널값 여부 확인을 할 수밖에 없도록 만든다.
 사용 중인 언어가 널 안전성을 지원한다면 사용하는 것이 좋다.
``` java
Optional<Element> getFifthElement(List<Element> elements) {
    if (elements.size() < 5) {
        return Optional.empty(); // Optional.empty() 가 널값 대신 반환된다.
    }
    return Optional.of(elements[4]);
}
```

## 2.2 왜 추상화 계층을 만드는가?
어떤 문제를 하위 문제로 곗혹해서 나누어 내려가면서 추상화 계층을 만든다면, 
**같은 층위 내에서는 쉽게 이해항 수 있는 몇 개의 개념만을 다루기 때문에 개별 코드는 특별히 복잡해 보이지 않을 것이다.** 
소프트웨어 엔지니어로서 문제를 해결할 때 이것이 목표가 되어야 한다.
문제가 엄청나게 복잡할지라도 하위 문제들을 식별하고 올바른 추상화 계층을 만듦으로써 복잡한 문제를 쉽게 다룰 수 있다.

### 2.2.1 추상화 계층 및 코드 품질의 핵심 요소
추상화 계층을 구축하면 코드 품질의 4가지 핵심 요소를 달성 할 수 있다.

#### 가독성
깨끗하고 뚜렷한 추상화 계층을 만드는 것은 개발자가 한두개 정도의 계층과 몇 개의 개념만 다루면 된다는 것을 의미한다.
따라서 코드의 가독성이 크게 향상된다.

#### 모듈화
추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부ㅡ로 노출되지 않도록 보장할 때, 
다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 매우 쉬워진다.

#### 재사용성 및 일반화성
하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기가 쉬워진다.   
문제가 적절하게 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 상황에서 유용하게 일반화될 가능성이 크다.

### 테스트 용이성
코드가 추상화 계층으로 깨끗하게 분할되면 각 하위 문제에 대한 해결책을 완벽하게 테스트하는 것이 훨씬 쉬워진다.

## 2.3 코드의 계층
추상화 계층을 생성하는 방법은 코드를 서로 다른 단위로 분할하여 단위 간의 의존 관계를 생성하는 것이다. 코드를 다른 단위로 나누기 위한 요소는 다음과 같다
- 함수
- 클래스
- 인터페이스
- 패키지, 네임스페이스, 모듈

<img width="600" alt="image" src="https://github.com/hyungjun-park/hyungjun-park.github.io/assets/9457532/e370d780-6506-418d-b104-372d8a85ded4">

**코드의 단위는 다른 단위에 의존하는데 이로 인해 의존성 그래프가 형성된다.**

### 2.3.1 API 및 구현 세부 사항
- 코드를 호출할 때 볼 수 있는 내용
  - 퍼블릭 클래스, 인터페이스 및 함수
  - 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념
  - 코드 호출 시 코드를 올바르게 사용하기 위해 알아야 하는 추가 정보
- 코드를 호출할 때 볼 수 없는 내용: 구현 세부 사항

API(Application Programming Interface)는 서비스를 사용할 때 알아야 할 것들에 대한 개념을 형식화하고, 서비스의 모든 구현 세부 사항은 API 뒤에 감춘다.

<img width="600" alt="image" src="https://github.com/hyungjun-park/hyungjun-park.github.io/assets/9457532/ae8c747e-29e5-48cc-85cb-68378fa79fb9">

**코드를 호출하는 쪽에서 그 코드에 대해 알고 있는 사항을 공개 API, 공개되지 않는 내용은 세부 사항이다.**   
API는 호출하는 쪽에 공개할 개념만 정의하면 되고 그 외 모든 것은 구현 세부 사항이기 때문에 코드를 API의 관점에서 생각하면 추상화 계층을 명확하게 만드는 데 도움이 된다.

### 2.3.2 함수
어떤 로직을 새로운 함수로 구현하면 대부분 유익하다. 각 함수에 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적이다.   
함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다. 코드를 작성하다 보면 너무 길어서 읽을 수 없는 함수가 되기 쉽다.
따라서 코드 작성을 일단 마치고 코드 검토 요청하기 전에 자신이 작성한 코드를 비판적으로 다시 살펴보는 것이 좋다.
함수를 한 문장으로 표현하기 어렵게 구현했다면 로직의 일부를 잘 명명된 헬퍼 함수로 분리하는 것을 고려해봐야 한다.

### 2.3.3 클래스
**클래스는 응집력이 있어야 하고 한 가지 일에만 관심을 가져야 한다.**

클래스 구조 설계와 코드 품질의 4가지 핵심 요소
- **코드 가독성:** 단일 클래스에 담겨 있는 개념이 많을수록 해당 클래스의 가독성은 저하된다. 
뇌는 의식적으로 많은 것을 동시에 생각하는 데 능숙하지 못하다. 인지적 부담을 많이 줄수록 시간은 더 오래 걸릴 것이고, 코드를 잘못 이해할 가능성은 더 커진다.
- **코드 모듈화:** 하위 문제에 대한 해결책이 하나의 클래스로 구현되어 있고, 다른 클래스와의 상호작용이 잘 준비된 퍼블릭 함수를 통해서만 이루어진다면, 
그 하위 문제에 대한 해결책의 구현을 다른 클래스로 교체할 필요가 있을 때 이것을 쉽게 할 수 있다.
- **코드 재사용성 및 일반화**
- **테스트 용이성 및 적절한 테스트:** 로직이 여러 클래스로 나누어지면 각 부분을 적절하게 테스트하기가 훨씬 쉬워진다.

코드를 적잘한 크기의 추상화 계층으로 나누면 한 번에 몇 가지 개념만 처리하는 코드로 만들 수 있다. 
이를 통해 **코드는 보다 더 읽기 쉽고, 모듈화되며, 재사용 가능하고, 일반화할 수 있고, 테스트가 쉬워진다.**

너무 많은 일을 하는 거대한 클래스는 코드 품질의 저하로 이어질 때가 많다. 클래스 구조를 설계할 때 코드 품질의 4가지 핵심 요소를 충족하는지 신중하게 생각하면 좋다.

### 2.3.4 인터페이스
추상화 계층을 깔끔하게 구현하는 코드를 만드는 데 있어 인터페이스는 매우 유용한 도구다. 
주어진 하위 문제에 대해 둘 이상의 서로 다른 구체적인 구현이 가능하고 이들 구현 클래스 사이에 전황이 필요할 대는 추상화 계층을 나타내는 인터페이스를 정의하는 것이 가장 좋다.
이를 통해 코드를 더욱 모듈화할 수 있고 재설정도 쉽게 할 수 있다.

**한 가지 구현만 있다면 인터페이스가 필요한가?**  
한 가지 구현만 있고 향후에 다른 구현을 추가할 계획이 없는 경우 인터페이스의 사용한 팀이 결정할 사안이다. 몇 몇 소프트웨어 공학 철학은 이 상황에서도 인터페이스를 사용할 것을 권고한다.

```java
/* 하나의 인터페이스 및 단일 구현 */
interface TextSummerizer {
    String summarizeTest(String text);
}

class TextSummarizerImpl implements TextSummerizer {
    
    @Override
    public String summarizeTest(String text) {
        /*
                process
         */
        return text;
    }
}
```
TextSummarizer의 하나의 구현에 대한 인터페이스 사용에 대한 몇 가지 장점
- **퍼블릭 API를 매우 명확하게 보여준다:** 이 계층에서 사용해야 하는 기능과 사용하지 말아야 하는 기능에 대해 혼동할 일이 없다. 
개발자가 TextSummarizerImpl 클래스에 새 퍼블릭 함수를 추가하더라도 상위 계층은 TextSummarizer 인터페이스에만 의존하기 때문에 이 함수는 그 상위 게층에 노출되지 않는다.
- **한 가지 구현만 일요하다고 잘못 추측한 것일 수 있다:** 원래 코드를 작성할 때는 또 다른 구현이 필요하지 않을 것이라고 확신하더라도 한두 달 후에는 이러한 가정이 잘못된 것으로 판명될 수 있다.
- **테스트를 쉽게 할 수 있다:** 구현 클래스가 복잡하거나 네트워크 I/O에 의존하는 작업을 수행한다면 테스트 중에 mock이나 페이크 객체로 대체할 수 있다.
- **같은 클래스로 두 가지 하위 문제를 해결할 수 있다:** 한 클래스가 두 개 이상의 서로 다른 추상화 계층에 구현을 제공할 수도 있다. 
예를 들어 LinkedList 구현 클래스는 List 및 Queue 인터페이스를 모두 구현한다. 즉, 어떤 상황에서는 큐의 구현 클래스가 되고 다른 상황에서는 리스트의 구현 클래스로 사용될 수 있다. 
이렇게 하면 코드의 일반화 가능성을 크게 높일 수 있다.

인터페이스를 정의할 때 단점
- **더 많은 작업이 필요하다:** 코드를 더 작성해야 한다

모든 클래스에 인터페이스를 붙이는 극단적인 입장의 코드는 종종 통제가 불가능하고, 불필요하게 복잡해지며, 이해와 수정이 어렵다. 
인터페이스를 사용할 경우 그 장점이 확실한 상황에서는 인터페이스를 사용하되, 인터페이스만을 위한 인터페이스를 작성해서는 안된다.
인터페이스를 정의하지 않더라도 클래스에서 어떤 함수를 퍼블릭으로 노출할지 매우 신중하게 생각해야 하며 구현 세부 사항이 유출되지 않도록 해야 한다. 
나중에 필요한 경우 인터페이스를 붙이는 것이 어려워 지지 않도록 코드를 작성해야 한다.

### 2.3.5 층이 너무 얇아질 때

## 2.4 마이크로서비스는 어떤가?


