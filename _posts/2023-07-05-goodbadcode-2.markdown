---
layout: post
title:  "[도서] Good Code, Bad Code - 2. 추상화 계층"
date:   2023-07-05 22:00:25 +0900
categories: book
---

# 2. 추상화 계층
**주요 내용**
- 깔끔한 추상화 계층을 통해 문제를 하위 문제로 세분화하는 방법
- 추상화 계층이 코드 품질의 요소를 달성하는 데 어떻게 도움이 되는지
- API 및 구현 세부 사항
- 함수, 클래스 및 인터페이스를 사용해 코드를 추상화 계층으로 나누는 방법

코드를 구성하는 방법은 코드 품질의 기본적인 측면 중 하나이며, 코드를 잘 구성한다는 것은 간결한 추상화 계층을 만드는 것으로 귀결될 때가 많다.
잘 추상화된 코드는 가독성, 모듈성, 재사용성, 일반화성 및 테스트 용이성이 크게 개선된다.

## 2.1 널값 및 의사코드 규약
> 해당 장의 예제 코드에서 어떻게 널값을 다루는지 설명하는 내용이다.

프로그래밍 언어에는 값이 없다는 개념을 표현하기 위해 널값을 사용한다. 이 널값은 유용하면서도 문제가 많다.
- 값이 제공되지 않거나 함수가 원하는 결과를 반환할 수 없는 경우가 자주 발생하기 때문에 '값이 없다' 또는 '부재한다'는 재념은 유용하다.
- 값이 널일 수 있거나 혹은 널이면 안 되는 경우가 항상 명백한 것은 아니라서 문제가 발생한다. 개발자들은 변수에 액세스하기 전에 널값인지 확인하는 것을 자주 잊어버린다. (NullPointException)

널 안전성(null safety) 혹은 보이드 안전성(void safety)에 대한 생각이 점점 더 많은 추진력을 얻고 있다. 이렇게 하면 널값이 가능할 경우 그에 맞게 표시해야 하고 컴파일러는 반드시 널값 여부 확인을 할 수밖에 없도록 만든다.
 사용 중인 언어가 널 안전성을 지원한다면 사용하는 것이 좋다.
``` java
Optional<Element> getFifthElement(List<Element> elements) {
    if (elements.size() < 5) {
        return Optional.empty(); // Optional.empty() 가 널값 대신 반환된다.
    }
    return Optional.of(elements[4]);
}
```

## 2.2 왜 추상화 계층을 만드는가?
어떤 문제를 하위 문제로 곗혹해서 나누어 내려가면서 추상화 계층을 만든다면, 
**같은 층위 내에서는 쉽게 이해항 수 있는 몇 개의 개념만을 다루기 때문에 개별 코드는 특별히 복잡해 보이지 않을 것이다.** 
소프트웨어 엔지니어로서 문제를 해결할 때 이것이 목표가 되어야 한다.
문제가 엄청나게 복잡할지라도 하위 문제들을 식별하고 올바른 추상화 계층을 만듦으로써 복잡한 문제를 쉽게 다룰 수 있다.

### 2.2.1 추상화 계층 및 코드 품질의 핵심 요소
추상화 계층을 구축하면 코드 품질의 4가지 핵심 요소를 달성 할 수 있다.

#### 가독성
깨끗하고 뚜렷한 추상화 계층을 만드는 것은 개발자가 한두개 정도의 계층과 몇 개의 개념만 다루면 된다는 것을 의미한다.
따라서 코드의 가독성이 크게 향상된다.

#### 모듈화
추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부ㅡ로 노출되지 않도록 보장할 때, 
다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 매우 쉬워진다.

#### 재사용성 및 일반화성
하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기가 쉬워진다.   
문제가 적절하게 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 상황에서 유용하게 일반화될 가능성이 크다.

### 테스트 용이성
코드가 추상화 계층으로 깨끗하게 분할되면 각 하위 문제에 대한 해결책을 완벽하게 테스트하는 것이 훨씬 쉬워진다.

## 2.3 코드의 계층
추상화 계층을 생성하는 방법은 코드를 서로 다른 단위로 분할하여 단위 간의 의존 관계를 생성하는 것이다. 코드를 다른 단위로 나누기 위한 요소는 다음과 같다
- 함수
- 클래스
- 인터페이스
- 패키지, 네임스페이스, 모듈

<img width="600" alt="image" src="https://github.com/hyungjun-park/hyungjun-park.github.io/assets/9457532/e370d780-6506-418d-b104-372d8a85ded4">

**코드의 단위는 다른 단위에 의존하는데 이로 인해 의존성 그래프가 형성된다.**

### 2.3.1 API 및 구현 세부 사항
- 코드를 호출할 때 볼 수 있는 내용
  - 퍼블릭 클래스, 인터페이스 및 함수
  - 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념
  - 코드 호출 시 코드를 올바르게 사용하기 위해 알아야 하는 추가 정보
- 코드를 호출할 때 볼 수 없는 내용: 구현 세부 사항

API(Application Programming Interface)는 서비스를 사용할 때 알아야 할 것들에 대한 개념을 형식화하고, 서비스의 모든 구현 세부 사항은 API 뒤에 감춘다.

<img width="600" alt="image" src="https://github.com/hyungjun-park/hyungjun-park.github.io/assets/9457532/ae8c747e-29e5-48cc-85cb-68378fa79fb9">

**코드를 호출하는 쪽에서 그 코드에 대해 알고 있는 사항을 공개 API, 공개되지 않는 내용은 세부 사항이다.**   
API는 호출하는 쪽에 공개할 개념만 정의하면 되고 그 외 모든 것은 구현 세부 사항이기 때문에 코드를 API의 관점에서 생각하면 추상화 계층을 명확하게 만드는 데 도움이 된다.

### 2.3.2 함수
어떤 로직을 새로운 함수로 구현하면 대부분 유익하다. 각 함수에 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적이다.   
함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다. 코드를 작성하다 보면 너무 길어서 읽을 수 없는 함수가 되기 쉽다.
따라서 코드 작성을 일단 마치고 코드 검토 요청하기 전에 자신이 작성한 코드를 비판적으로 다시 살펴보는 것이 좋다.
함수를 한 문장으로 표현하기 어렵게 구현했다면 로직의 일부를 잘 명명된 헬퍼 함수로 분리하는 것을 고려해봐야 한다.

### 2.3.3 클래스

### 2.3.4 인터페이스

### 2.3.5 층이 너무 얇아질 때

## 2.4 마이크로서비스는 어떤가?


